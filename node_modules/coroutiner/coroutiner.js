// Generated by CoffeeScript 1.9.2
(function() {
  var Coroutiner, merge, ref, typeOf,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('lutils'), merge = ref.merge, typeOf = ref.typeOf;


  /*
  	Creates a new coroutiner instance.
  	
  	@param newTypes {Object} An object which will merge with the coroutiner.types object
  	@param Promise {Function Promise} Your own Promise implimentation
  		@default require('bluebird')
   */

  module.exports = new (Coroutiner = function(options) {
    var coroutiner;
    if (options == null) {
      options = {};
    }

    /*
    		Enumerates over an Object or Array, turning generator functions
    		into Promise.coroutine()'s. Not recursive.
    
    		@param obj {Object or Array or Function}
    		@param validator {Function} (Optional)
    			This function will be run for each property. When `false` is returned by validator, a property is skipped.
    			
    			@param key
    			@param value
    			@param parent
    		
    		@return obj
     */
    coroutiner = function(obj, validator, types) {
      var key, val;
      if (validator == null) {
        validator = coroutiner.validator;
      }
      if (types == null) {
        types = coroutiner.types;
      }
      for (key in obj) {
        val = obj[key];
        if (types.unowned === false && !obj.hasOwnProperty(key)) {
          continue;
        }
        if (coroutiner.isGenerator(val)) {
          if ((typeof validator === "function" ? validator(key, val, obj) : void 0) === false) {
            continue;
          }
          obj[key] = coroutiner.create(val, types);
        }
      }
      coroutiner.prototypeHandler(obj, types, function(proto) {
        return coroutiner(proto, validator, types);
      });
      return obj;
    };
    coroutiner.prototypeHandler = function(obj, types, iterator) {
      var type;
      if (types.prototype) {
        type = typeOf(obj);
        if (type === 'function' && obj.prototype) {
          return iterator(obj.prototype);
        } else if (type === 'object' && Object.keys(obj.__proto__).length) {
          return iterator(obj.__proto__);
        }
      }
    };
    coroutiner.Promise = options.Promise || require('bluebird');
    coroutiner.transformer = options.transformer || coroutiner.Promise.coroutine;
    coroutiner.validator = null;
    coroutiner.depth = options.depth || 20;
    coroutiner.types = {
      object: true,
      "function": true,
      array: true,
      prototype: false,
      unowned: true,
      circular: false
    };
    merge.white(coroutiner.types, options);
    coroutiner.isGenerator = function(fn) {
      return typeOf.Function(fn) && fn.constructor.name === 'GeneratorFunction';
    };
    coroutiner.create = function(fn, types) {
      var newFn;
      if (types == null) {
        types = coroutiner.types;
      }
      newFn = coroutiner.transformer(fn);
      merge(newFn, fn, 1, types);
      return newFn;
    };

    /*
    		Enumerates over all properties and any iterable properties, such as Objects and Functions.
    		
    		@param obj {Object or Array or Function}
    		@param depth {Number}
    		@param validator {Function} (Optional)
    			This function will be run for each property. When `false` is returned by validator, a property is skipped.
    			
    			@param key
    			@param value
    			@param parent
    		
    		@param types {Object}
    			Determines which properties will be enumerated over in this structure:
    				{ 'object': true }
    			
    			When an `object`, `function`, `array` etc. is `true`, it will be enumerated within `obj`.
     */
    coroutiner.all = function(obj, validator, depth, types) {
      var cyclicStore, iterator;
      if (validator == null) {
        validator = coroutiner.validator;
      }
      if (depth == null) {
        depth = coroutiner.depth;
      }
      if (types == null) {
        types = coroutiner.types;
      }
      cyclicStore = [];
      iterator = function(obj, validator, depth, types) {
        var key, type, val;
        if (--depth > 0) {
          for (key in obj) {
            val = obj[key];
            if (types.unowned === false && !obj.hasOwnProperty(key)) {
              continue;
            }
            type = typeOf(val);
            if (type in types) {
              if (types.circular === false) {
                if (indexOf.call(cyclicStore, val) >= 0) {
                  continue;
                }
                cyclicStore.unshift(val);
              }
            }
            if (type === 'function' && coroutiner.isGenerator(val)) {
              if ((typeof validator === "function" ? validator(key, val, obj) : void 0) === false) {
                continue;
              }
              if (types["function"]) {
                iterator(val, validator, depth, types);
              }
              obj[key] = coroutiner.create(val, types);
            } else if (type in types) {
              iterator(val, validator, depth, types);
            }
          }
          coroutiner.prototypeHandler(obj, types, function(proto) {
            return iterator(proto, validator, depth, types);
          });
        }
        return obj;
      };
      return iterator(obj, validator, depth, types);
    };
    coroutiner.Coroutiner = Coroutiner;
    return coroutiner;
  });

}).call(this);
