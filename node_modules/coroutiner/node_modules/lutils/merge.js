// Generated by CoffeeScript 1.9.2
(function() {
  var merge, typeOf,
    hasProp = {}.hasOwnProperty;

  typeOf = require('./typeOf');


  /*
  	Merge the second object into the first recursively until depth is reached for each property.
  	
  	@param obj1 {Object}
  	@param obj2 {Object} Merged into obj1
  	@param depth {Number}
  	@param types {Array} Array of types to iterate over. Defaults to ['object']
  	@return obj1
   */

  module.exports = merge = function(obj1, obj2, depth, types) {
    if (depth == null) {
      depth = merge.depth;
    }
    if (types == null) {
      types = merge.types;
    }
    return merge.iterate(obj1, obj2, depth, merge.castTypes(types));
  };


  /*
  	Whitelisted merge.
  	Merges properties into object1 from object only if the property exists in object1
   */

  merge.white = function(obj1, obj2, depth, types) {
    return merge.by(obj1, obj2, depth, types, true);
  };


  /*
  	Blacklisted merge.
  	Merges properties into object1 from object only if the property *doesnt* exist in object1
   */

  merge.black = function(obj1, obj2, depth, types) {
    return merge.by(obj1, obj2, depth, types, false);
  };


  /*
  	Defaults
   */

  merge.depth = 8;

  merge.types = {
    object: true
  };

  merge.castTypes = function(types) {
    var i, key, len, obj;
    if (typeOf.Object(types)) {
      return types;
    }
    obj = {};
    for (i = 0, len = types.length; i < len; i++) {
      key = types[i];
      obj[key] = true;
    }
    return obj;
  };

  merge.iterate = function(obj1, obj2, depth, types) {
    var key, obj1Type, obj2Type;
    if (--depth >= 0) {
      for (key in obj2) {
        if (!hasProp.call(obj2, key)) continue;
        obj2Type = typeOf(obj2[key]);
        obj1Type = typeOf(obj1[key]);
        if ((obj2Type in types) && key in obj1 && (obj1Type in types)) {
          merge.iterate(obj1[key], obj2[key], depth, types);
        } else {
          obj1[key] = obj2[key];
        }
      }
    }
    return obj1;
  };


  /*
  	Merge obj1 and obj2 by replacing values where both objects share the same keys, preffering obj1
   */

  merge.by = function(obj1, obj2, depth, types, whiteList) {
    if (depth == null) {
      depth = merge.depth;
    }
    if (types == null) {
      types = merge.types;
    }
    if (whiteList == null) {
      whiteList = true;
    }
    return merge.by.iterate(obj1, obj2, depth, merge.castTypes(types), whiteList);
  };

  merge.by.iterate = function(obj1, obj2, depth, types, whiteList) {
    var key, obj1Type, obj2Type, ref;
    if (--depth >= 0) {
      ref = (!whiteList ? obj2 : obj1);
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        obj2Type = typeOf(obj2[key]);
        obj1Type = typeOf(obj1[key]);
        if ((obj2Type in types) && (obj1Type in types)) {
          merge.by.iterate(obj1[key], obj2[key], depth, types, whiteList);
        } else if (!((!whiteList && key in obj1) || (whiteList && !(key in obj2)))) {
          obj1[key] = obj2[key];
        }
      }
    }
    return obj1;
  };

}).call(this);
