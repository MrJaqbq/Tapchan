// Generated by CoffeeScript 1.9.3
(function() {
  var lastError, minify, path;

  path = require('path');

  minify = require('./format').minify;

  lastError = 0;


  /*
  	Prettifies error messages for the console.
  	
  	@param err {Error or String} The error to parse
  	@param scope {String} A supplimentary context note
  	@param reverse {Boolean} Whether to reverse the ordering
  	@return {String}
   */

  module.exports = function(err, scope, reverse) {
    var all, basename, charPos, count, dirname, file, filePath, grayStack, i, len, line, lineNo, lines, m, message, now, originalMessage, ref, ref1, ref2, regex, stack, str, variable, variableExtra;
    if (!(err instanceof Error)) {
      err = new Error(err);
    }
    originalMessage = err.message.split('\n')[0].toString();
    message = originalMessage.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    regex = new RegExp("" + message, 'i');
    lines = ((err != null ? err.stack : void 0) || err || '').toString().split('\n');
    stack = [];
    grayStack = [];
    count = 0;
    ref = lines.slice(1);
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      line = line.replace(/\t/g, '    ');
      ref1 = [], all = ref1[0], variable = ref1[1], variableExtra = ref1[2], file = ref1[3];
      if (m = line.match(/^\s*at\s*([^\(]+)\s*\(([^\)]+)\)/i)) {
        all = m[0], variable = m[1], file = m[2];
        if (variableExtra = ((ref2 = variable.match(/\s*\[(as[^\]]+)\]/i)) != null ? ref2[1] : void 0) || '') {
          variable = variable.replace("[" + variableExtra + "]", '');
        }
        variable = minify(variable);
      } else if (m = line.match(/^\s*at\s*(\S+)\s*$/)) {
        all = m[0], file = m[1];
      }
      if (file = minify(file)) {
        if (file.match(/^\/.+\/node_modules\/bluebird|^native|^(node|module).js:/i)) {
          continue;
        }
        if (m = file.toString().match(/([^:]+):(\d+):(\d+)/)) {
          filePath = m[1];
          lineNo = m[2];
          charPos = m[3];
          dirname = path.dirname(filePath) + '/';
          basename = path.basename(filePath);
          str = variable ? " " + lineNo.bold + "\t " + charPos + "\t" + variable + (variableExtra ? ' ' + variableExtra.grey : '') + "\n\t" : " " + lineNo.bold + "\t " + charPos;
          stack.push(str + ("\t" + dirname.grey + basename.cyan + "\n"));
        } else {
          str = variable ? " \t\t" + variable + (variableExtra ? ' ' + variableExtra.grey : '') + "\n" : '';
          stack.push(str + (" \t\t" + file.cyan + "\n"));
        }
      } else {
        if (count > 500) {
          continue;
        }
        grayStack.push(' ' + line.grey);
        ++count;
      }
    }
    if (reverse !== false) {
      stack.reverse();
    }
    stack = stack.concat(grayStack);
    now = new Date();
    stack.push((" + " + (now - lastError) + " ms").gray);
    lastError = now;
    stack.push(' ' + lines[0].red.bold + '\n');
    stack.unshift('');
    return stack.join('\n');
  };

  module.exports.reverse = function(err, scope) {
    return module.exports(err, scope, false);
  };

}).call(this);
