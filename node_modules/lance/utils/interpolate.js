// Generated by CoffeeScript 1.9.1

/*
	Subsitutes data into a string

	@param str {String} The string to subistute data into: "This is a {{parent.child}}"
	@param data {Object} { parent: { child: 'pie' } }
	@return {String} "This is a pie"
 */

(function() {
  var interpolate;

  module.exports = interpolate = function(str, data) {
    var j, k, len, len1, match, matches, newStr, notFound, pointer, prop, props, raw, regexp, type;
    if (data == null) {
      data = {};
    }
    newStr = str;
    matches = [];
    regexp = /\{\{([^\{\}]+)\}\}/ig;
    while (match = regexp.exec(str)) {
      if (match[1]) {
        matches.push(match);
      }
    }
    if (matches.length) {
      for (j = 0, len = matches.length; j < len; j++) {
        match = matches[j];
        raw = match[0], props = match[1];
        props = props.split('.');
        pointer = data;
        notFound = false;
        for (k = 0, len1 = props.length; k < len1; k++) {
          prop = props[k];
          type = typeOf(pointer);
          if (type === 'object' || type === 'array' || type === 'function') {
            if (!(prop in pointer)) {
              notFound = true;
              break;
            }
            pointer = pointer[prop];
          }
        }
        if (notFound) {
          newStr = newStr.replace(raw, '');
        } else {
          newStr = newStr.replace(raw, pointer);
        }
      }
    }
    return newStr;
  };


  /*
  	Substitutes identifiers like {{settings.variable}} with values.
   */

  interpolate.all = function(data, dataSet, depth, interpDepth) {
    var clonedData, iterator;
    if (depth == null) {
      depth = 10;
    }
    if (interpDepth == null) {
      interpDepth = 4;
    }
    if (!dataSet) {
      dataSet = data;
    } else if (typeOf.Number(dataSet)) {
      depth = dataSet;
      dataSet = data;
    }
    clonedData = clone.merge.hard(data);
    return (iterator = function(data, depth) {
      var i, j, key, ref, val;
      if (--depth < 1) {
        return data;
      }
      for (key in data) {
        val = data[key];
        switch (typeOf(val)) {
          case 'string':
            for (i = j = 1, ref = interpDepth; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
              data[key] = interpolate(data[key], clonedData);
            }
            break;
          case 'object':
          case 'array':
            data[key] = iterator(val, depth);
        }
      }
      return data;
    })(data, depth);
  };

}).call(this);
