// Generated by CoffeeScript 1.9.1
(function() {
  var transpose, typeOf,
    hasProp = {}.hasOwnProperty;

  typeOf = require('./core/typeOf');


  /*
  	Parses a string of javascript object notation into its representation and sets an end value
  
  	@param obj {Object} 'info[1].prop'
  	@param value {Object} 'value!'
  	@return {Object} { info: [ , { prop: 'value!' } } ] }
   */

  module.exports = transpose = function(bindings, value) {
    var binding, i, index, item, j, key, last, len, len1, map, next, parent, parts, ref, ref1;
    if (typeof bindings === 'string') {
      key = bindings;
      bindings = {};
      bindings[key] = value;
    }
    for (binding in bindings) {
      value = bindings[binding];
      parts = binding.match(/([\w]+)|(\[["']?[^\[]+["']?\])/g);
      map = [];
      for (i = 0, len = parts.length; i < len; i++) {
        item = parts[i];
        if (key = (ref = item.match(/^\[([^\[]+)\]$/)) != null ? ref[1] : void 0) {
          if (/^\d+$/.test(key)) {
            parent = [];
            key = parseInt(key);
          } else {
            key = key.replace(/^['"]|['"]$/g, '');
            parent = {};
          }
        } else {
          key = item;
          parent = {};
        }
        map.push({
          key: key,
          parent: parent
        });
      }
      if (!map.length) {
        continue;
      }
      next = bindings;
      last = map[0];
      if (map[0].key !== binding) {
        delete bindings[binding];
      }
      ref1 = map.slice(1);
      for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
        item = ref1[index];
        if (!(last.key in next)) {
          next[last.key] = item.parent;
        }
        next = next[last.key];
        last = item;
      }
      next[last.key] = value;
    }
    return bindings;
  };

  transpose.set = function(transposed, data, val) {
    if (typeOf.String(transposed)) {
      transposed = transpose(transposed, val);
    }
    return transpose.merge.force(data, transposed);
  };


  /*
  	Merges between two objects/arrays yet preferres obj2 values when @param `force` is true
   */

  transpose.merge = function(obj1, obj2, depth, force) {
    var key, val1, val1Iterable, val1Type, val2, val2Iterable, val2Type;
    if (depth == null) {
      depth = 16;
    }
    if (depth > 0) {
      for (key in obj2) {
        if (!hasProp.call(obj2, key)) continue;
        val1 = obj1[key];
        val2 = obj2[key];
        val1Type = typeOf(val1);
        val2Type = typeOf(val2);
        val1Iterable = val1Type === 'object' || val1Type === 'array';
        val2Iterable = val2Type === 'object' || val2Type === 'array';
        if (key in obj1) {
          if (val1Iterable && val2Iterable) {
            if (force && (val1Type !== val2Type || (val2Type === 'array' && !val2.length) || (val2Type === 'object' && !Object.keys(val2).length > 0))) {
              obj1[key] = val2;
            } else {
              transpose.merge(val1, val2, depth - 1, force);
            }
          } else if (force) {
            obj1[key] = val2;
          }
        } else {
          obj1[key] = val2;
        }
      }
    }
    return obj1;
  };

  transpose.merge.force = function(obj1, obj2, depth) {
    return transpose.merge(obj1, obj2, depth, true);
  };

  transpose.find = function(transposed, data) {
    var iterator;
    if (typeOf.String(transposed)) {
      transposed = transpose(transposed);
    }
    iterator = function(pos1, pos2) {
      var key1, state1, state2, type, val1;
      state1 = (type = typeOf(pos1)) === 'object' || type === 'array';
      state2 = (type = typeOf(pos2)) === 'object' || type === 'array';
      if (state1 && state2) {
        for (key1 in pos1) {
          val1 = pos1[key1];
          break;
        }
        if (key1 in pos2) {
          return iterator(val1, pos2[key1]);
        }
      } else if (!state1) {
        return pos2;
      }
      return void 0;
    };
    return iterator(transposed, data);
  };

}).call(this);
