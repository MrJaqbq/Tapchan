// Generated by CoffeeScript 1.9.1
(function() {
  var merge, typeOf,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  typeOf = require('./typeOf');


  /*
  	Merge
  	
  	Merge obj1 by replacing values in obj1 with those from obj2. Iterates nested objects.
  	
  	@param obj1 {Object}
  	@param obj2 {Object} Merged into obj1
  	@param depth {Number}
  	@param iterators {Array} Array of types to iterate over. Defaults to ['object']
  	@return obj1
   */

  module.exports = merge = function(obj1, obj2, depth, iterators) {
    if (depth == null) {
      depth = 8;
    }
    iterators || (iterators = ['object']);
    return merge.iterate(obj1, obj2, depth, iterators);
  };

  merge.iterate = function(obj1, obj2, depth, iterators) {
    var key, obj1Type, obj2Type;
    if (depth > 0) {
      for (key in obj2) {
        if (!hasProp.call(obj2, key)) continue;
        obj2Type = typeOf(obj2[key]);
        obj1Type = typeOf(obj1[key]);
        if ((indexOf.call(iterators, obj2Type) >= 0) && key in obj1 && (indexOf.call(iterators, obj1Type) >= 0)) {
          arguments.callee(obj1[key], obj2[key], depth - 1, iterators);
        } else {
          obj1[key] = obj2[key];
        }
      }
    }
    return obj1;
  };

  merge.by = function(obj1, obj2, depth, iterators, whiteList) {
    if (depth == null) {
      depth = 8;
    }
    if (whiteList == null) {
      whiteList = true;
    }
    iterators || (iterators = ['object']);
    return merge.by.iterate(obj1, obj2, depth, iterators, whiteList);
  };

  merge.by.iterate = function(obj1, obj2, depth, iterators, whiteList) {
    var key, obj1Type, obj2Type, ref;
    if (depth > 0) {
      ref = (!whiteList ? obj2 : obj1);
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        if ((!whiteList && key in obj1) || (whiteList && !(key in obj2))) {
          continue;
        }
        obj2Type = typeOf(obj2[key]);
        obj1Type = typeOf(obj1[key]);
        if ((indexOf.call(iterators, obj2Type) >= 0) && (indexOf.call(iterators, obj1Type) >= 0)) {
          arguments.callee(obj1[key], obj2[key], depth - 1, iterators, whiteList);
        } else {
          obj1[key] = obj2[key];
        }
      }
    }
    return obj1;
  };

  merge.white = function(obj1, obj2, depth, iterators) {
    return merge.by(obj1, obj2, depth, iterators, true);
  };

  merge.black = function(obj1, obj2, depth, iterators) {
    return merge.by(obj1, obj2, depth, iterators, false);
  };

}).call(this);
