// Generated by CoffeeScript 1.9.3
(function() {
  var Emitter, Router, clone, merge, ref, typeOf,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Emitter = require('events').EventEmitter;

  ref = require('../utils'), clone = ref.clone, merge = ref.merge, typeOf = ref.typeOf;

  module.exports = Router = (function(superClass) {
    var fn, i, len, method, ref1;

    extend(Router, superClass);

    function Router(newCfg, lance) {
      var i, len, method, ref1;
      this.lance = lance;
      this.cfg = clone(require('../config').router);
      if (newCfg) {
        merge(this.cfg, newCfg);
      }
      this.routes = {};
      this.namedRoutes = {};
      this.indexes = {};
      this.defaultResult = {
        path: {},
        splats: [],
        name: '',
        callback: false,
        pattern: '',
        regex: null
      };
      ref1 = this.methods;
      for (i = 0, len = ref1.length; i < len; i++) {
        method = ref1[i];
        this.routes[method] = [];
        this.indexes[method] = {};
      }
    }

    Router.prototype.methods = ['get', 'post', 'head', 'put', 'delete', 'trace', 'connect', 'options', 'patch'];

    ref1 = Router.prototype.methods;
    fn = function(method) {
      return Router.prototype[method] = Router.prototype[method.toUpperCase()] = function(patterns, name, callback) {
        return this.route(method, patterns, name, callback);
      };
    };
    for (i = 0, len = ref1.length; i < len; i++) {
      method = ref1[i];
      fn(method);
    }

    Router.prototype.all = function(patterns, name, callback) {
      var j, len1, ref2;
      ref2 = this.methods;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        method = ref2[j];
        this.route(method, patterns, name, callback);
      }
      return null;
    };

    Router.prototype['*'] = Router.prototype.all;

    Router.prototype.add = function(method, pattern, name, callback) {
      var index, keys, regex, route;
      keys = [];
      regex = pattern;
      if (typeof regex === 'string') {
        regex = this.patternToRegex(pattern, keys);
      }
      pattern = (pattern || '').toString();
      index = this.routes[method].length + 1;
      route = {
        name: name || index,
        callback: callback,
        regex: regex,
        pattern: pattern,
        keys: keys
      };
      this.routes[method].push(route);
      this.namedRoutes[name || pattern] = route;
      this.emit('route', route);
      return route;
    };

    Router.prototype.route = function(method, patterns, name, callback) {
      var args, name1, pattern, results, returnFirst;
      if (name == null) {
        name = '';
      }
      if (callback == null) {
        callback = function() {};
      }
      if (typeOf.Array(args = method)) {
        return typeof this[name1 = args[0]] === "function" ? this[name1].apply(this, args.slice(1)) : void 0;
      }
      if (!patterns || !method) {
        return false;
      }
      method = method.toLowerCase();
      if (!(method in this.routes)) {
        this.lance.emit('err', new Error("`" + method + "` method is unsupported/invalid"));
        return false;
      }
      if (returnFirst = typeOf.String(patterns)) {
        patterns = [patterns];
      }
      if (typeOf.Function(name)) {
        callback = name;
        name = '';
      }
      results = (function() {
        var j, len1, results1;
        results1 = [];
        for (j = 0, len1 = patterns.length; j < len1; j++) {
          pattern = patterns[j];
          results1.push(this.add(method, pattern, name, callback));
        }
        return results1;
      }).call(this);
      if (returnFirst) {
        return results[0];
      } else {
        return results;
      }
    };

    Router.prototype.match = function(urlPath, method, skipTo) {
      var captures, index, indexPath, j, k, key, len1, len2, path, ref2, result, route, splats, val, varName;
      if (urlPath == null) {
        urlPath = '';
      }
      if (method == null) {
        method = 'get';
      }
      if (skipTo == null) {
        skipTo = 0;
      }
      if (!urlPath) {
        this.lance.emit('err', new Error("`" + urlPath + "` urlPath is invalid", 'Lance.Router.match'));
        return this.defaultResult;
      }
      method = method.toLowerCase();
      if (this.routes[method] === void 0) {
        this.lance.emit('err', new Error("`" + method + "` method is unsupported/invalid", 'Lance.Router.match'));
        return this.defaultResult;
      }
      this.emit('matching', urlPath, method, skipTo);
      indexPath = skipTo + ":" + urlPath;

      /*
      			TODO: make this on by default and more robust:
      			It needs to first contain all matching steps in a route, not just the endpoint.
      			The result should only count "o.next()" calls though, although it may already do that.
       */
      if (this.cfg.cache && this.indexes[method][indexPath] !== void 0) {
        return this.indexes[method][indexPath];
      }
      ref2 = this.routes[method];
      for (index = j = 0, len1 = ref2.length; j < len1; index = ++j) {
        route = ref2[index];
        if (skipTo > index) {
          continue;
        }
        path = {};
        splats = [];
        captures = urlPath.match(route.regex);
        if (!captures || captures.length < 1) {
          continue;
        }
        captures = captures.slice(1);
        for (key = k = 0, len2 = captures.length; k < len2; key = ++k) {
          val = captures[key];
          varName = route.keys[key];
          val = (val || '').toString();
          try {
            val = decodeURIComponent(val);
          } catch (_error) {}
          if (varName) {
            path[varName] = val;
          } else {
            splats.push(val);
          }
        }
        result = {
          index: index,
          path: path,
          splats: splats,
          name: route.name,
          callback: route.callback,
          pattern: route.pattern,
          regex: route.regex
        };
        this.emit('matched', result);
        if (this.cfg.cache) {
          this.indexes[method][indexPath] = result;
        }
        return result;
      }
      return this.defaultResult;
    };

    Router.prototype.patternToRegex = function(pattern, keys) {
      pattern = pattern.concat('/?').replace(/\/\(/g, '(?:/').replace(/(\/)?(\.)?:(\w+)(\(.*?\))?(\?)?/g, function(match, slash, format, key, rematch, optional) {
        var result;
        keys.push(key);
        slash = slash || '';
        optional = optional || '';
        rematch = rematch || '([^/]+?)';
        format = format || '';
        result = '';
        if (!optional) {
          result += slash;
        }
        result += '(?:';
        if (optional) {
          result += slash;
        }
        result += format + rematch + ')' + optional;
        return result;
      }).replace(/([\/.])/g, function(match, str) {
        return '\\' + str;
      }).replace(/\*/g, '(.+)');
      return new RegExp("^" + pattern + "$", 'i');
    };

    return Router;

  })(Emitter);

}).call(this);
