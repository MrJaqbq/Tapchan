// Generated by CoffeeScript 1.9.3
(function() {
  var Browserify, CoffeeReactify, Coffeeify, Promise, Templater, UglifyJs, clone, cluster, coroutiner, exploreDir, format, fs, merge, mkdirp, path, ref, typeOf, watch,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Promise = require('bluebird');

  path = require('path');

  fs = Promise.promisifyAll(require('fs'));

  cluster = require('cluster');

  mkdirp = Promise.promisify(require('mkdirp'));

  watch = require('watch');

  try {
    Browserify = require('browserify');
  } catch (_error) {}

  try {
    UglifyJs = require('uglify-js');
  } catch (_error) {}

  try {
    CoffeeReactify = require('coffee-reactify');
  } catch (_error) {}

  try {
    Coffeeify = require('coffeeify');
  } catch (_error) {}

  ref = require('../utils'), clone = ref.clone, merge = ref.merge, typeOf = ref.typeOf, format = ref.format, coroutiner = ref.coroutiner, exploreDir = ref.exploreDir;

  module.exports = Templater = function() {
    this.constructor = (function(_this) {
      return function(newCfg, lance) {
        var Ect, assets, baseTransforms, coffee, css, engine, js, key, match, model, models, oldCfg, ref1, ref2, ref3, stylus, templater;
        _this.lance = lance;
        oldCfg = require('../config').templater;
        _this.cfg = clone.json(oldCfg);
        if (newCfg) {
          merge(_this.cfg, newCfg);
        }
        _this.cfg.root = _this.cfg.root || _this.lance.paths.root;
        _this.locals = _this.cfg.locals;
        _this.cfg.bundles = _this.cfg.bundles || _this.cfg.bundle;
        ref1 = _this.cfg, stylus = ref1.stylus, coffee = ref1.coffee, templater = ref1.templater, css = ref1.css, js = ref1.js, assets = ref1.assets;
        models = {
          stylus: stylus,
          coffee: coffee,
          templater: templater,
          css: css,
          js: js,
          assets: assets
        };
        if (css.inherit) {
          css.findIn || (css.findIn = stylus.findIn);
          css.saveTo || (css.saveTo = stylus.saveTo);
        }
        if (js.inherit) {
          js.findIn || (js.findIn = coffee.findIn);
          js.saveTo || (js.saveTo = coffee.saveTo);
        }
        if (stylus.inherit) {
          stylus.findIn || (stylus.findIn = css.findIn);
          stylus.saveTo || (stylus.saveTo = css.saveTo);
        }
        if (coffee.inherit) {
          coffee.findIn || (coffee.findIn = js.findIn);
          coffee.saveTo || (coffee.saveTo = js.saveTo);
        }
        try {
          coffee.engine = coffee.engine || require('coffee-script');
        } catch (_error) {}
        try {
          stylus.engine = stylus.engine || require('stylus');
        } catch (_error) {}
        if (Browserify && !((ref2 = _this.cfg.browserify.transform) != null ? ref2.length : void 0)) {
          baseTransforms = [];
          if (CoffeeReactify != null) {
            baseTransforms.push([
              CoffeeReactify, {
                global: true
              }
            ]);
          } else if (Coffeeify != null) {
            baseTransforms.push([
              Coffeeify, {
                global: true
              }
            ]);
          }
          if (baseTransforms.length) {
            _this.cfg.browserify.transform = baseTransforms;
          }
        }
        if (!css.match) {
          css.match = css.ext;
        }
        if (!js.match) {
          js.match = js.ext;
        }
        if (!stylus.match) {
          stylus.match = stylus.ext;
        }
        if (!coffee.match) {
          coffee.match = coffee.ext;
        }
        for (key in models) {
          model = models[key];
          if (match = model.match) {
            model.matchFn = typeOf.String(match) ? function(fileDir) {
              if (fileDir == null) {
                fileDir = '';
              }
              return _this.file.checkExtension(fileDir, match);
            } : typeOf.RegExp(match) ? function(fileDir) {
              if (fileDir == null) {
                fileDir = '';
              }
              return match.test(fileDir);
            } : typeOf.Function(match) ? match : void 0;
          }
          if (!typeOf.Function(model.render)) {
            delete model.render;
          }
          if (!typeOf.Function(model.watch)) {
            delete model.watch;
          }
          if ('saveTo' in model && (model.saveTo == null)) {
            model.saveTo = _this.cfg.saveTo || '';
          }
          if ('findIn' in model && (model.findIn == null)) {
            model.findIn = _this.cfg.findIn || '';
          }
        }
        if (templater.engine == null) {
          try {
            Ect = require('ect');
          } catch (_error) {}
          if (Ect != null) {
            templater.options || (templater.options = {});
            merge.black(templater.options, templater.ect);
            _this.templater.useEct(templater, Ect);
          }
        } else {
          engine = ((ref3 = templater.engine) != null ? ref3.renderFile : void 0) || templater.engine.render || templater.engine;
          templater.engine = function(relativePath, data, done) {
            var filePath;
            filePath = format.fileExtension(relativePath, _this.templater.ext);
            filePath = _this.file.resolve(filePath, _this.templater.findIn);
            return engine(filePath, data, done);
          };
        }
        if (!templater.engine) {
          throw new Error('Invalid templating engine');
        }
        for (key in models) {
          model = models[key];
          merge(_this[key], model, 1);
        }
        return _this;
      };
    })(this);
    this.initialize = (function(_this) {
      return function() {
        var await;
        await = [_this.bundle()];
        if (_this.assets.findIn && _this.assets.saveTo) {
          await.push(_this.assets.syncDirectory());
        }
        return Promise.all(await);
      };
    })(this);

    /*
    		Alias to `@templater.render`.
     */
    this.render = (function(_this) {
      return function(filePath, locals) {
        return _this.templater.render(filePath, locals);
      };
    })(this);

    /*
    		The templater, for templating files!
     */
    this.templater = {
      render: (function(_this) {
        return function*(filePath, locals) {
          var rendered;
          if (filePath == null) {
            filePath = '';
          }
          _this.lance.emit('templater.render.template', filePath, locals);
          if (locals) {
            locals = merge.black(locals, clone(_this.locals, 6));
          } else {
            locals = _this.locals;
          }
          rendered = (yield new Promise(function(resolve, reject) {
            return _this.templater.engine(filePath, locals, function(err, rendered) {
              if (rendered == null) {
                rendered = '';
              }
              if (err) {
                return reject(err);
              }
              return resolve(rendered);
            });
          }));
          if (_this.templater.minify && rendered) {
            rendered = format.minify(rendered);
          }
          return rendered;
        };
      })(this),
      useEct: (function(_this) {
        return function(templater, Ect) {
          var engine;
          if (!templater.options.root) {
            templater.options.root = templater.findIn ? _this.file.resolveToRoot(templater.findIn) : _this.cfg.root;
          }
          templater.options.ext = templater.ext = templater.ext || templater.options.ext || '.ect';
          engine = Ect(templater.options);
          return templater.engine = engine.render;
        };
      })(this)
    };
    this.stylus = {
      render: (function(_this) {
        return function*(fileDir, destination) {
          var dependencies, engine, file, promise;
          if (_this.stylus.disabled) {
            return Promise.resolve();
          }
          fileDir = _this.file.resolve(fileDir, _this.stylus.findIn);
          _this.lance.emit('templater.render.stylus', fileDir);
          file = (yield _this.file.read(fileDir));
          if (!_this.stylus.engine) {
            throw new Error("Stylus is not installed");
          }
          engine = _this.stylus.engine(file, _this.stylus.options);
          engine.set('paths', [path.dirname(fileDir), _this.file.resolveToRoot(_this.stylus.findIn)]);
          engine.set('filename', fileDir);
          dependencies = engine.deps();
          promise = new Promise(function(resolve, reject) {
            return engine.render(function(err, rendered) {
              var newFileDir, results;
              if (rendered == null) {
                rendered = '';
              }
              if (err) {
                return reject(err);
              }
              if (!rendered) {
                return resolve(rendered);
              }
              if (_this.stylus.minify) {
                rendered = format.minifyCss(rendered);
              }
              results = [rendered, dependencies, engine];
              if (destination) {
                newFileDir = _this.file.createSaveToPath(destination || fileDir, {
                  ext: _this.css.ext,
                  findIn: _this.stylus.findIn,
                  saveTo: _this.stylus.saveTo
                });
                if (dependencies && _this.cfg.watch) {
                  _this.stylus.watchDependencies(dependencies, fileDir, function() {
                    try {
                      return _this.stylus.render(fileDir, destination);
                    } catch (_error) {
                      err = _error;
                      return console.error(err);
                    }
                  });
                }
                return resolve(_this.file.write(newFileDir, rendered)["return"](results));
              } else {
                return resolve(results);
              }
            });
          });
          return promise["catch"](function(err) {
            return _this.lance.emit('err', err);
          });
        };
      })(this),
      watchDependencies: (function(_this) {
        return function(dependencies, fileDir, callback) {
          var dep, i, len, listeners;
          listeners = _this.stylus.listeners[fileDir] || [];
          if (indexOf.call(dependencies, fileDir) < 0) {
            dependencies.push(fileDir);
          }
          for (i = 0, len = dependencies.length; i < len; i++) {
            dep = dependencies[i];
            if (!(indexOf.call(listeners, dep) < 0)) {
              continue;
            }
            listeners.push(dep);
            _this.watch.once(dep);
            _this.lance.on("templater.watch.change." + dep, callback);
          }
          return _this.stylus.listeners[fileDir] = listeners;
        };
      })(this),
      listeners: {}
    };
    this.coffee = {
      render: (function(_this) {
        return function*(fileDir, destination) {
          var file, newFileDir, rendered, result;
          if (_this.coffee.disabled) {
            return null;
          }
          fileDir = _this.file.resolve(fileDir, _this.coffee.findIn);
          _this.lance.emit('templater.render.coffee', fileDir);
          file = (yield _this.file.read(fileDir));
          if (!_this.coffee.engine) {
            throw new Error('CoffeeScript is not installed');
          }
          rendered = _this.coffee.engine.compile(file);
          newFileDir = _this.file.createSaveToPath(destination || fileDir, {
            ext: _this.js.ext,
            findIn: _this.coffee.findIn,
            saveTo: _this.coffee.saveTo
          });
          if (_this.coffee.minify) {
            try {
              if ((UglifyJs != null) && (result = UglifyJs.minify(rendered, {
                fromString: true,
                mangle: false
              }))) {
                rendered = result.code;
              }
            } catch (_error) {}
          }
          return _this.file.write(newFileDir, rendered);
        };
      })(this)
    };
    this.js = {
      render: (function(_this) {
        return function*(fileDir, destination) {
          var newFileDir, rendered, result;
          if (_this.js.disabled) {
            return null;
          }
          fileDir = _this.file.resolve(fileDir, _this.js.findIn);
          _this.lance.emit('templater.render.js', fileDir);
          rendered = (yield _this.file.read(fileDir));
          newFileDir = _this.file.createSaveToPath(destination || fileDir, _this.js);
          if (_this.js.minify) {
            try {
              if ((UglifyJs != null) && (result = UglifyJs.minify(rendered, {
                fromString: true,
                mangle: false
              }))) {
                rendered = result.code;
              }
            } catch (_error) {}
          }
          return _this.file.write(newFileDir, rendered);
        };
      })(this)
    };
    this.css = {
      render: (function(_this) {
        return function*(fileDir, destination) {
          var file, newFileDir;
          if (_this.css.disabled) {
            return null;
          }
          fileDir = _this.file.resolve(fileDir, _this.css.findIn);
          _this.lance.emit('templater.render.css', fileDir);
          file = (yield _this.file.read(fileDir));
          newFileDir = _this.file.createSaveToPath(destination || fileDir, _this.css);
          if (_this.css.minify) {
            file = format.minifyCss(file);
          }
          return _this.file.write(newFileDir, file);
        };
      })(this)
    };
    this.assets = {
      watching: {},
      render: (function(_this) {
        return function*(fileDir, destination) {
          var newFileDir, readStream;
          if (_this.assets.disabled) {
            return null;
          }
          fileDir = _this.file.resolve(fileDir, _this.assets.findIn);
          _this.lance.emit('templater.render.assets', fileDir);
          if (!((yield _this.file.exists(fileDir)))) {
            throw new Error(fileDir + " doesnt exist");
          }
          newFileDir = _this.file.createSaveToPath(destination || fileDir, _this.assets);
          readStream = fs.createReadStream(fileDir);
          return _this.file.writeStream(readStream, newFileDir);
        };
      })(this),
      syncDirectory: (function(_this) {
        return function*(root) {
          var await, monitorDirectory, o;
          if (root == null) {
            root = _this.assets.findIn;
          }
          root = _this.file.resolveToRoot(root);
          await = [];
          o = {};
          if (_this.assets.matchFn != null) {
            o.filter = function(file) {
              return _this.assets.matchFn(file);
            };
          }
          monitorDirectory = function(filePath) {
            if (_this.assets.watching[filePath]) {
              return null;
            }
            _this.assets.watching[filePath] = true;
            return watch.createMonitor(filePath, o, function(monitor) {
              var dir, file, ref1;
              ref1 = monitor.files;
              for (dir in ref1) {
                file = ref1[dir];
                if (file.isFile()) {
                  await.push(_this.assets.render(dir));
                }
              }
              if (_this.cfg.watch) {
                monitor.on('created', function(fileDir, stats) {
                  _this.lance.emit('templater.watch.created', fileDir, stats);
                  _this.lance.emit("templater.watch.created." + fileDir, fileDir, stats);
                  if (stats.isFile() && _this.assets.matchFn(fileDir)) {
                    return _this.assets.render(fileDir);
                  } else if (stats.isDirectory()) {
                    return _this.assets.syncDirectory(fileDir);
                  }
                });
                monitor.on('changed', function(fileDir) {
                  _this.lance.emit('templater.watch.change', fileDir);
                  _this.lance.emit("templater.watch.change." + fileDir, fileDir);
                  return _this.assets.render(fileDir);
                });
                return monitor.on('removed', function(fileDir) {
                  _this.lance.emit('templater.watch.removed', fileDir);
                  return _this.lance.emit("templater.watch.removed." + fileDir, fileDir);
                });
              }
            });
          };
          monitorDirectory(root);
          (yield exploreDir(root, {
            depth: _this.cfg.depth || 8,
            directory: monitorDirectory,
            ignorePrefix: _this.assets.ignorePrefix
          }));
          return (yield Promise.all(await));
        };
      })(this)
    };
    this.assets.find = (function(_this) {
      return function(findIn, next) {
        findIn = findIn || _this.assets.findIn;
        return _this.find(findIn, _this.assets.match, next);
      };
    })(this);
    this.assets.find.watch = (function(_this) {
      return function(findIn) {
        return _this.assets.find(findIn, function(file, fileDir) {
          return _this.watch.asset(fileDir);
        });
      };
    })(this);
    this.assets.find.render = (function(_this) {
      return function*(findIn) {
        var await;
        await = [];
        (yield _this.assets.find(findIn, function(file, fileDir) {
          return await.push(_this.assets.render(fileDir));
        }));
        return Promise.all(await);
      };
    })(this);
    this.assets.find.renderAndWatch = (function(_this) {
      return function*(findIn) {
        var await;
        await = [];
        (yield _this.assets.find(findIn, function(file, fileDir) {
          await.push(_this.assets.render(fileDir));
          return _this.assets.watch(fileDir);
        }));
        return Promise.all(await);
      };
    })(this);
    this.bundle = (function(_this) {
      return function(arg) {
        var await, cfg, destination, files, fn, i, len;
        if (arg == null) {
          arg = _this.cfg.bundles;
        }
        await = [];
        switch (typeOf(arg)) {
          case 'object':
            for (destination in arg) {
              files = arg[destination];
              await.push(_this.bundle.render(files, destination));
            }
            break;
          case 'array':
            fn = function(cfg) {
              destination = cfg.destination || cfg.saveTo || cfg.to;
              files = cfg.files || cfg.file || cfg.source || cfg.from;
              return await.push(_this.bundle.render(files, destination));
            };
            for (i = 0, len = arg.length; i < len; i++) {
              cfg = arg[i];
              fn(cfg);
            }
            break;
          default:
            await.push(_this.bundle.render.apply(_this, arguments));
        }
        return Promise.all(await);
      };
    })(this);

    /*
    		Checks the first file in the files parameter to determine to render it toJs or toCss.
     */
    this.bundle.render = (function(_this) {
      return function*(files, destination) {
        var firstFile;
        firstFile = typeOf.Array(files) ? files[0] : files;
        if (_this.file.isToJs(firstFile)) {
          return (yield _this.bundle.render.toJs.apply(_this, arguments));
        } else if (_this.file.isToCss(firstFile)) {
          return (yield _this.bundle.render.toCss.apply(_this, arguments));
        }
      };
    })(this);
    this.bundle.watchDependencies = (function(_this) {
      return function(dependencies, key, callback) {
        var dep, i, len, listeners;
        listeners = _this.bundle.listeners[key] || [];
        for (i = 0, len = dependencies.length; i < len; i++) {
          dep = dependencies[i];
          if (!(indexOf.call(listeners, dep) < 0)) {
            continue;
          }
          listeners.push(dep);
          _this.watch.once(dep);
          _this.lance.on("templater.watch.change." + dep, callback);
        }
        return _this.bundle.listeners[key] = listeners;
      };
    })(this);
    this.bundle.listeners = {};

    /*
    		Bundles up js/coffee-script with browserify.
    
    		@param destination {String}
    		@param files {String} {Array} Either one fileDir as a string or many in an array
     */
    this.bundle.render.toJs = (function(_this) {
      return function*(files, destination) {
        var args, b, fileDir, i, index, model, readStream, saveTo;
        args = arguments;
        if (!typeOf.Array(files)) {
          files = [files];
        }
        for (index = i = files.length - 1; i >= 0; index = i += -1) {
          fileDir = files[index];
          model = _this.file.resolveModel(fileDir);
          if (model.disabled) {
            files.splice(index, 1);
            continue;
          }
          files[index] = _this.file.resolve(fileDir, model.findIn);
        }
        if (!files.length) {
          return null;
        }
        if (Browserify == null) {
          throw new Error('Browserify is not installed');
        }
        b = Browserify(files, _this.cfg.browserify);
        if (_this.cfg.watch) {
          b.on('file', function(fileDir) {
            return _this.bundle.watchDependencies([fileDir], destination, function() {
              var err;
              try {
                return _this.bundle.render.toJs.apply(_this, args);
              } catch (_error) {
                err = _error;
                return _this.lance.emit('err', err);
              }
            });
          });
        }
        _this.lance.emit('templater.bundle.render', destination);
        readStream = b.bundle().on('error', Promise.method(function(err) {
          return typeof readStream.end === "function" ? readStream.end() : void 0;
        }));
        saveTo = _this.file.createSaveToPath(destination);
        return (yield _this.file.writeStream(readStream, saveTo));
      };
    })(this);

    /*
    		Bundles up css/stylus. Only accepts ONE file as `source`
    
    		@param destination {String}
    		@param source {String}
     */
    this.bundle.render.toCss = (function(_this) {
      return function*(fileDirs, destination) {
        var allDeps, args, dependencies, engine, engines, fileDir, i, index, inputIsArray, j, len, model, newFileDir, ref1, rendered, renders;
        args = arguments;
        if (inputIsArray = typeOf.Array(fileDirs)) {
          allDeps = [];
          engines = [];
          renders = [];
          for (index = i = fileDirs.length - 1; i >= 0; index = i += -1) {
            fileDir = fileDirs[index];
            model = _this.file.resolveModel(fileDir);
            if (model.disabled) {
              fileDirs.splice(index, 1);
              continue;
            }
            fileDirs[index] = _this.file.resolve(fileDir, model.findIn);
          }
          if (!fileDirs.length) {
            return null;
          }
          _this.lance.emit('templater.bundle.render', destination);
          for (index = j = 0, len = fileDirs.length; j < len; index = ++j) {
            fileDir = fileDirs[index];
            ref1 = (yield _this.stylus.render(fileDir)), rendered = ref1[0], dependencies = ref1[1], engine = ref1[2];
            allDeps.push(fileDir);
            if (dependencies) {
              allDeps = allDeps.concat(dependencies);
            }
            engines.push(engine);
            renders.push(rendered);
          }
          rendered = renders.join('\n');
          if (destination) {
            newFileDir = _this.file.createSaveToPath(destination || fileDir, {
              ext: _this.css.ext,
              findIn: _this.stylus.findIn,
              saveTo: _this.stylus.saveTo
            });
            if (_this.cfg.watch) {
              _this.bundle.watchDependencies(allDeps, newFileDir, function() {
                var err;
                try {
                  return _this.bundle.render.toCss.apply(_this, args);
                } catch (_error) {
                  err = _error;
                  return console.error(err);
                }
              });
            }
            (yield _this.file.write(newFileDir, rendered));
          }
          return [rendered, allDeps, engines];
        } else {
          fileDir = fileDirs;
          model = _this.file.resolveModel(fileDir);
          if (!model.disabled) {
            _this.lance.emit('templater.bundle.render', destination);
            return _this.stylus.render(fileDir, destination);
          }
        }
        return;
      };
    })(this);
    this.watch = (function(_this) {
      return function(fileDir, callback) {
        if (!fileDir || !_this.cfg.watch) {
          return false;
        }
        _this.lance.emit('templater.watch', fileDir);
        fs.watch(fileDir, function(event) {
          if (event !== 'change') {
            return false;
          }
          if (fileDir in _this.watch.timeouts) {
            clearTimeout(_this.watch.timeouts[fileDir]);
          }
          return _this.watch.timeouts[fileDir] = setTimeout(function() {
            _this.lance.emit('templater.watch.change', fileDir, event);
            _this.lance.emit("templater.watch.change." + fileDir, fileDir, event);
            delete _this.watch.timeouts[fileDir];
            if (callback) {
              return callback(fileDir, event);
            }
          }, _this.cfg.watchTimeout);
        });
        return true;
      };
    })(this);
    this.watch.timeouts = {};
    this.watch.once = (function(_this) {
      return function(fileDir, callback) {
        if (!(fileDir in _this.watch.once.watching)) {
          if (_this.watch(fileDir, callback)) {
            return _this.watch.once.watching[fileDir] = true;
          }
        }
      };
    })(this);
    this.watch.once.watching = {};
    this.file = {};
    this.file.deferredWrite = (function(_this) {
      return function(key, fileDir, file) {
        return new Promise(function(resolve) {
          var cache;
          if (cache = _this.file.deferredWrite.timeouts[key]) {
            cache.resolve();
          } else {
            cache = _this.file.deferredWrite.timeouts[key] = {};
          }
          cache.fulfill = function() {
            return _this.file.write(fileDir, file);
          };
          cache.resolve = resolve;
          return _this.file.deferredWrite.refresh(key);
        });
      };
    })(this);
    this.file.deferredWrite.timeouts = {};
    this.file.deferredWrite.refresh = (function(_this) {
      return function(key, time) {
        var cache;
        if (time == null) {
          time = _this.cfg.writeTimeout;
        }
        if (cache = _this.file.deferredWrite.timeouts[key]) {
          if (cache.timeout) {
            clearTimeout(cache.timeout);
          }
          return cache.timeout = setTimeout(function() {
            cache.resolve(_this.file.deferredWrite.timeouts[key].fulfill());
            return delete _this.file.deferredWrite.timeouts[key];
          }, time);
        }
      };
    })(this);
    this.file.resolve = (function(_this) {
      return function(dir, root) {
        var model;
        if (dir == null) {
          dir = '';
        }
        if (root == null) {
          root = '';
        }
        if (!root) {
          if (model = _this.file.resolveModel(dir)) {
            root = model.findIn;
          }
        }
        root = _this.file.resolveToRoot(root || _this.cfg.root);
        if (path.isAbsolute(dir)) {
          return dir;
        } else {
          return path.join(root, dir);
        }
      };
    })(this);
    this.file.resolveToRoot = (function(_this) {
      return function(dir) {
        if (path.isAbsolute(dir)) {
          return dir;
        } else {
          return path.join(_this.cfg.root, dir);
        }
      };
    })(this);
    this.file.resolveModel = (function(_this) {
      return function(fileDir) {
        switch (false) {
          case !_this.file.checkExtension(fileDir, _this.coffee.ext):
            return _this.coffee;
          case !_this.file.checkExtension(fileDir, _this.js.ext):
            return _this.js;
          case !_this.file.checkExtension(fileDir, _this.stylus.ext):
            return _this.stylus;
          case !_this.file.checkExtension(fileDir, _this.css.ext):
            return _this.css;
          case !_this.file.checkExtension(fileDir, _this.templater.ext):
            return _this.templater;
        }
      };
    })(this);
    this.file.read = (function(_this) {
      return function*(fileDir, encoding) {
        if (!((yield _this.file.exists(fileDir)))) {
          throw new Error(fileDir + " doesnt exist");
        }
        if (!encoding && encoding !== false) {
          encoding = 'utf8';
        }
        return fs.readFileAsync(fileDir, encoding);
      };
    })(this);
    this.file.write = (function(_this) {
      return function*(fileDir, file) {
        var result;
        if (_this.cfg.debugging.fileWriting === false) {
          return null;
        }
        (yield _this.file.createDirectory(fileDir));
        result = (yield fs.writeFileAsync(fileDir, file));
        _this.lance.emit('templater.writeFile', fileDir);
        return result;
      };
    })(this);
    this.file.writeStream = (function(_this) {
      return function*(readStream, fileDir) {
        var writeStream;
        if (_this.cfg.debugging.fileWriting === false) {
          return null;
        }
        (yield _this.file.createDirectory(fileDir));
        writeStream = fs.createWriteStream(fileDir);
        return new Promise(function(resolve, reject) {
          var error, errored;
          errored = false;
          error = function(err) {
            if (!errored) {
              reject(err);
            }
            return errored = true;
          };
          readStream.once('error', error);
          writeStream.once('error', error);
          return readStream.pipe(writeStream).on('error', error).on('close', function() {
            _this.lance.emit('templater.writeFile', fileDir);
            return resolve();
          });
        });
      };
    })(this);
    this.file.createDirectory = (function(_this) {
      return function(fileDir, done) {
        if (done == null) {
          done = function() {};
        }
        return new Promise(function(resolve, reject) {
          return mkdirp(path.dirname(fileDir), _this.cfg.writePermissions || (0x1ed & (~process.umask())), function(err) {
            return resolve();
          });
        });
      };
    })(this);
    this.file.createSaveToPath = (function(_this) {
      return function(fileDir, model) {
        var ext, findIn, newFileDir, partial, saveTo;
        if (!model) {
          model = _this.file.resolveModel(fileDir);
        }
        findIn = model.findIn, saveTo = model.saveTo, ext = model.ext;
        if (typeOf.Array(findIn)) {
          findIn = findIn[0];
        }
        findIn = _this.file.resolve(findIn);
        saveTo = _this.file.resolve(saveTo);
        fileDir = _this.file.resolve(fileDir, findIn);
        findIn = new RegExp('^' + format.escapeRegExp(findIn));
        partial = _this.cfg.preserveDirectory ? fileDir.replace(findIn, '') : path.basename(fileDir);
        newFileDir = path.join(saveTo, partial);
        if (ext) {
          newFileDir = format.fileExtension(newFileDir, ext);
        }
        return newFileDir;
      };
    })(this);
    this.file.exists = (function(_this) {
      return function(fileDir) {
        return new Promise(function(resolve) {
          return fs.exists(fileDir, resolve);
        });
      };
    })(this);
    this.file.checkExtension = (function(_this) {
      return function(filePath, ext) {
        var regex;
        if (!filePath || typeof filePath !== 'string' || !ext) {
          return false;
        }
        regex = ext != null ? (ext = ext.replace(/^\./, ''), new RegExp("." + ext + "$", 'i')) : /\.([^\.]+)$/;
        return filePath != null ? filePath.match(regex) : void 0;
      };
    })(this);
    this.file.isToJs = (function(_this) {
      return function(fileDir) {
        return _this.file.checkExtension(fileDir, _this.coffee.ext) || _this.file.checkExtension(fileDir, _this.js.ext);
      };
    })(this);
    this.file.isToCss = (function(_this) {
      return function(fileDir) {
        return _this.file.checkExtension(fileDir, _this.stylus.ext) || _this.file.checkExtension(fileDir, _this.css.ext);
      };
    })(this);
    coroutiner.all(this);
    return this.constructor.apply(this, arguments);
  };

}).call(this);
