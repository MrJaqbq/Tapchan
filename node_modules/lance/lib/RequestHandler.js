// Generated by CoffeeScript 1.9.3
(function() {
  var Busboy, Cookies, Promise, RequestHandler, clone, coroutiner, crypto, fs, merge, os, parseUrl, path, querystring, ref, transposer, typeOf, zlib,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Promise = require('bluebird');

  Cookies = require('cookies');

  Busboy = require('busboy');

  path = require('path');

  os = require('os');

  fs = require('fs');

  parseUrl = require('url').parse;

  querystring = require('querystring');

  zlib = require('zlib');

  crypto = require('crypto');

  transposer = new (require('transposer'));

  ref = require('../utils'), merge = ref.merge, typeOf = ref.typeOf, clone = ref.clone, coroutiner = ref.coroutiner;

  module.exports = coroutiner(RequestHandler = (function() {
    function RequestHandler(req, res, lance) {
      this.req = req;
      this.res = res;
      this.lance = lance;
      this.serveHttpCode = bind(this.serveHttpCode, this);
      this.serveRedirect = bind(this.serveRedirect, this);
      this.serveJson = bind(this.serveJson, this);
      this.serveTemplate = bind(this.serveTemplate, this);
      this.serve = bind(this.serve, this);
      this.time = new Date();
      this.code = 200;
      this.headers = {
        'content-type': 'text/html; charset=utf-8'
      };
      this.body = '';
      this.json = {};
      this.template = {
        view: '',
        data: {},
        templater: this.lance.templater
      };
      this.redirect = '';
      this.redirectQuery = {};
      this.query = {};
      this.serve.redirect = this.serveRedirect;
      this.serve.template = this.serveTemplate;
      this.serve.json = this.serveJson;
      this.serve.code = this.serveHttpCode;
      this.lance.emit('request.unparsed', this);
    }

    RequestHandler.prototype.serve = function(template) {
      var err;
      if (template) {
        merge(this.template, template);
      }
      try {
        this.lance.emit('serve', this);
        if (this.redirect) {
          return this.serve.redirect();
        } else {
          if (this.template.view) {
            return this.serve.template();
          } else {
            return this.serve.json();
          }
        }
      } catch (_error) {
        err = _error;
        this.lance.emit('err', err);
        return this.serve.code(500);
      }
    };

    RequestHandler.prototype.serveTemplate = function*(view, data) {
      var err, rendered;
      if (view == null) {
        view = this.template.view;
      }
      if (data == null) {
        data = this.template.data;
      }
      try {
        this.lance.emit('serveTemplate', this);
        this.lance.emit('serve.template', this);
        if (view) {
          data = merge({
            query: this.query,
            o: {
              time: this.time,
              code: this.code,
              headers: this.headers,
              body: this.body,
              encoding: this.encoding,
              json: this.json,
              template: this.template,
              redirect: this.redirect,
              redirectQuery: this.redirectQuery,
              query: this.query,
              method: this.method,
              route: this.route,
              path: this.path,
              splats: this.splats,
              cookies: this.cookies,
              files: this.files,
              session: this.session
            }
          }, data);
          rendered = (yield this.template.templater.render(view, data));
          this.body = rendered;
        }
                return this.respond();;
      } catch (_error) {
        err = _error;
        this.lance.emit('err', err);
        this.serve.code(500);
      }
      return;
    };

    RequestHandler.prototype.serveJson = function(json) {
      this.lance.emit('serveJson', this);
      this.lance.emit('serve.json', this);
      this.res.statusCode = this.code;
      this.res.setHeader('content-type', 'application/json');
      return this.res.end(JSON.stringify(json || this.json));
    };

    RequestHandler.prototype.serveRedirect = function(path, query) {
      var hash, ref1;
      if (path == null) {
        path = this.redirect;
      }
      if (query == null) {
        query = this.redirectQuery;
      }
      this.lance.emit('serveRedirect', this);
      this.lance.emit('serve.redirect', this);
      if (hash = (ref1 = path.match(/(#[\w\d_-]+)/i)) != null ? ref1[1] : void 0) {
        path = path.replace(hash, '');
      }
      if (Object.keys(query).length) {
        path += '?' + querystring.stringify(query);
      }
      if (hash) {
        path += hash;
      }
      this.res.statusCode = 302;
      this.res.setHeader('location', path);
      return this.res.end();
    };

    RequestHandler.prototype.serveHttpCode = function(code, body, headers) {
      var key, title, val;
      if (code == null) {
        code = this.code;
      }
      if (body == null) {
        body = '';
      }
      if (headers == null) {
        headers = {
          'content-type': 'text/plain; charset=utf-8'
        };
      }
      this.lance.emit('serveHttpCode', this);
      this.lance.emit('serve.code', this);
      this.res.statusCode = code;
      for (key in headers) {
        val = headers[key];
        this.res.setHeader(key, val);
      }
      if (body) {
        return this.res.end(body);
      } else {
        title = require('http').STATUS_CODES[code.toString()] || '';
        return this.res.end(code + " " + title);
      }
    };

    RequestHandler.prototype.parse = function*() {
      this.lance.emit('request.parse', this);
      (yield this.parseRequest());
      this.lance.emit('request', this);
      if (this.route.callback) {
        this.route.callback.apply(this.lance, [this]);
      } else {
        this.lance.requestCallback.apply(this.lance, [this]);
      }
      return this;
    };

    RequestHandler.prototype.respond = function() {
      var compressor, key, length, ref1, stream, type, val;
      this.lance.emit('respond', this);
      this.res.statusCode = this.code;
      ref1 = this.headers;
      for (key in ref1) {
        val = ref1[key];
        this.res.setHeader(key, val);
      }
      stream = new require('stream').Readable();
      switch (type = typeOf(this.body)) {
        case 'string':
          stream.push(this.body);
          stream.push(null);
          break;
        default:
          stream.pipe(this.body);
      }
      if (this.lance.cfg.server.compress) {
        if (compressor = this.compress()) {
          stream = stream.pipe(compressor);
        }
      }
      if (compressor == null) {
        length = Buffer.byteLength(this.body.toString(), 'utf8');
        this.res.setHeader('content-length', length || 0);
      }
      return stream.pipe(this.res);
    };

    RequestHandler.prototype.compress = function() {
      var acceptEncoding;
      acceptEncoding = this.req.headers['accept-encoding'] || '';
      if (acceptEncoding.match(/\bgzip\b/i)) {
        this.res.setHeader('content-encoding', 'gzip');
        return zlib.createGzip(this.lance.cfg.compress.createGzip);
      } else if (acceptEncoding.match(/\bdeflate\b/i)) {
        this.res.setHeader('content-encoding', 'deflate');
        return zlib.createDeflate(this.lance.cfg.compress.createDeflate);
      } else {
        return null;
      }
    };

    RequestHandler.prototype.compressSync = function(body) {
      var acceptEncoding;
      acceptEncoding = this.req.headers['accept-encoding'] || '';
      return new Promise(function(resolve, reject) {
        var handler;
        handler = function(err, body) {
          if (err) {
            return reject(err);
          }
          return resolve(body);
        };
        if (acceptEncoding.match(/\bgzip\b/i)) {
          this.res.setHeader('content-encoding', 'gzip');
          return zlib.gzip(body, handler);
        } else if (acceptEncoding.match(/\bdeflate\b/i)) {
          this.res.setHeader('content-encoding', 'deflate');
          return zlib.deflate(body, handler);
        } else {
          this.res.setHeader('content-length', body.length || 0);
          return resolve(body);
        }
      });
    };

    RequestHandler.prototype.next = function() {
      var newRoute, url;
      url = this.route.url;
      newRoute = this.lance.router.match(url.pathname, this.method, this.route.index + 1);
      newRoute.url = url;
      this.route = newRoute;
      this.path = newRoute.path;
      this.splats = newRoute.splats;
      if (newRoute.callback) {
        newRoute.callback(this);
      }
      return this;
    };

    RequestHandler.prototype.setQueryField = function(data, field, value) {
      if (field in data) {
        if (!typeOf.Array(data[field])) {
          data[field] = [data[field]];
        }
        return data[field].push(value);
      } else {
        return data[field] = value;
      }
    };

    RequestHandler.prototype.handleFile = function(field, stream, filename, encoding, mimetype) {
      var deleteFile, ext, fileExt, length, mimeExt, newFileName, ref1, tempFilePath, timeout, type;
      fileExt = path.extname(filename).slice(1);
      mimeExt = '';
      if (this.lance.data.mimetypes[fileExt] === mimetype) {
        mimeExt = fileExt;
      } else {
        ref1 = this.lance.data.mimetypes;
        for (ext in ref1) {
          type = ref1[ext];
          if (!(type === mimetype)) {
            continue;
          }
          mimeExt = ext;
          break;
        }
      }
      if (!filename || !mimeExt || stream.truncated) {
        stream.resume();
        return null;
      }
      newFileName = new Date().getTime() + crypto.randomBytes(2).toString('hex') + '.' + mimeExt;
      tempFilePath = path.join(os.tmpDir(), newFileName);
      length = 0;
      timeout = null;
      deleteFile = function() {
        return new Promise(function(resolve) {
          clearTimeout(timeout);
          return fs.exists(tempFilePath, function(exists) {
            if (exists) {
              return fs.unlink(tempFilePath, resolve);
            } else {
              return resolve();
            }
          });
        });
      };
      this.setQueryField(this.files, field, {
        field: field,
        filename: filename,
        encoding: encoding,
        mimetype: mimetype,
        file: tempFilePath,
        truncated: stream != null ? stream.truncated : void 0,
        ext: mimeExt,
        "delete": deleteFile
      });
      timeout = setTimeout(deleteFile, this.lance.cfg.server.tempTimeout);
      return new Promise(function(resolve, reject) {
        var writeStream;
        writeStream = fs.createWriteStream(tempFilePath).on('finish', resolve).on('error', reject);
        return stream.pipe(writeStream);
      });
    };

    RequestHandler.prototype.parseDataFallback = function*() {
      var postBody;
      postBody = '';
      return (yield new Promise((function(_this) {
        return function(resolve, reject) {
          _this.req.on('data', function(chunk) {
            return postBody += chunk;
          });
          return _this.req.on('end', function() {
            _this.query = querystring.parse(postBody) || {};
            return resolve();
          });
        };
      })(this)));
    };

    RequestHandler.prototype.parseData = function*() {
      var options, postBody;
      this.query = {};
      this.files = {};
      postBody = '';
      switch (this.method) {
        case 'GET':
          return this.query = this.route.url.query || {};
        default:
          options = clone(this.lance.cfg.server.busboy);
          merge(options, {
            headers: this.req.headers
          });
          return new Promise((function(_this) {
            return function(resolve, reject) {
              var awaiting, err;
              try {
                _this.stream = new Busboy(options);
              } catch (_error) {
                err = _error;
                return resolve(_this.parseDataFallback());
              }
              awaiting = [];
              _this.stream.on('file', function() {
                return awaiting.push(_this.handleFile.apply(_this, arguments));
              });
              _this.stream.on('field', function(field, value, truncatedField, truncatedVal) {
                return _this.setQueryField(_this.query, field, value);
              });
              _this.stream.on('finish', function() {
                return resolve(Promise.all(awaiting));
              });
              return _this.req.pipe(_this.stream);
            };
          })(this));
      }
    };

    RequestHandler.prototype.parseRequest = function*() {
      var url;
      this.method = this.req.method.toUpperCase();
      url = parseUrl(this.req.url, true);
      this.route = this.lance.router.match(url.pathname, this.method);
      this.route.url = url;
      this.path = this.route.path;
      this.splats = this.route.splats;
      this.cookies = new Cookies(this.req, this.res);
      (yield this.parseData());
      return this.query = transposer.transposeAll(this.query);
    };

    return RequestHandler;

  })());

}).call(this);
